<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="THREADPOOLEXECUTOR成员变量及内部类WORKER的属性详解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586">
<meta property="og:type" content="article">
<meta property="og:title" content="线程池源码详解(ThreadPoolExecutor)(2)">
<meta property="og:url" content="http://example.com/2022/03/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3(ThreadPoolExecutor)(2)/index.html">
<meta property="og:site_name" content="Whole">
<meta property="og:description" content="THREADPOOLEXECUTOR成员变量及内部类WORKER的属性详解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-03-22T10:04:15.000Z">
<meta property="article:modified_time" content="2022-03-31T06:00:10.859Z">
<meta property="article:author" content="小鲸鱼">
<meta property="article:tag" content="线程池">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/03/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3(ThreadPoolExecutor)(2)/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>线程池源码详解(ThreadPoolExecutor)(2) | Whole</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Whole</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3(ThreadPoolExecutor)(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/whole.png">
      <meta itemprop="name" content="小鲸鱼">
      <meta itemprop="description" content="凡事以理想为因,实行为过">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Whole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          线程池源码详解(ThreadPoolExecutor)(2)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-22 18:04:15" itemprop="dateCreated datePublished" datetime="2022-03-22T18:04:15+08:00">2022-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-31 14:00:10" itemprop="dateModified" datetime="2022-03-31T14:00:10+08:00">2022-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="THREADPOOLEXECUTOR成员变量及内部类WORKER的属性详解"><a href="#THREADPOOLEXECUTOR成员变量及内部类WORKER的属性详解" class="headerlink" title="THREADPOOLEXECUTOR成员变量及内部类WORKER的属性详解"></a>THREADPOOLEXECUTOR成员变量及内部类WORKER的属性详解</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	主池控制状态，ctl，是一个原子整数包装两个概念字段workerCount，有效线程数runState，线程池状态</span></span><br><span class="line"><span class="comment">		(1):1：workerCount 线程池种有效线程数  2: runState 运行状态 例如运行 ，关闭等</span></span><br><span class="line"><span class="comment">	为了将它们打包到一个 int 中，我们将 workerCount 限制为 (2^29)-1（大约 5 亿）个线程，而不是 (2^31)-1 (十亿) 个线程，workerCount占用低29位，runState占用高三位</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">	<span class="comment">//线程数容量，低29位表示有效线程数，0001,1111,1111,1111,1111,1111,1111,1111</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//  运行状态(从小到大)</span></span><br><span class="line">		<span class="number">1110</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> 运行 -<span class="number">1</span> &lt;&lt; COUNT_BITS</span><br><span class="line">	    <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> 关闭 <span class="number">0</span> &lt;&lt; COUNT_BITS</span><br><span class="line"> 	    <span class="number">0010</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> 停止 <span class="number">1</span> &lt;&lt; COUNT_BITS</span><br><span class="line">  		<span class="number">0100</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> 整理 <span class="number">2</span> &lt;&lt; COUNT_BITS</span><br><span class="line"> 		<span class="number">0110</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> 终止 <span class="number">3</span> &lt;&lt; COUNT_BITS</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="comment">//接受新任务并处理排队的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;<span class="comment">//不接受新任务，但处理排队的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;<span class="comment">//不接受新任务，不处理排队的任务，并中断正在进行的任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;<span class="comment">//所有任务都已终止，workerCount 为零， 转换到状态 TIDYING 的线程 将运行 terminate() 钩子方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;<span class="comment">//终止已完成</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Ctl高三位也即是运行时状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">	<span class="comment">//获取Ctl低29位也即是有效线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">	<span class="comment">//得到ctl值，高三位与低29位或运算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;   </span><br><span class="line">	<span class="comment">//判断运行时状态的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateLessThan</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">runStateAtLeast</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= s;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//判断线程池是否处于运行状态，因为比SHUTDOWN小的只有Running</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isRunning</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c &lt; SHUTDOWN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以CAS的方式增加有效线程数(WorkerCount)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndIncrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctl.compareAndSet(expect, expect + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以CAS的方式减少有效线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndDecrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="comment">//ctl 的 workerCount 字段减一。这仅在线程突然终止时调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">decrementWorkerCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于AQS实现的Lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//包含池中所有工作线程的集合。仅在 持有 mainLock 时访问,worker集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//支持 awaitTermination 的等待条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">termination</span> <span class="operator">=</span> mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跟踪获得的最大池大小。只能在 mainLock 下访问。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已完成任务的计数器(总的完成线程数)。仅在终止工作线程时更新。只能在 mainLock 下访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程工厂</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">//拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空闲线程的超市时间</span></span><br><span class="line">	<span class="comment">//核心线程是否回收与allowCoreThreadTimeOut()方法有关，当位true时，核心线程使用完也会一同会被回收，默认缺省值为false</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否允许核心线程超时，默认false，false情况下核心线程会一直存活。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心线程的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认的拒绝策略,直接抛异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RuntimePermission</span> <span class="variable">shutdownPerm</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;modifyThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Worker类，每个Worker包含一个线程、一个初始任务、一个任务计算器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Worker对应的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="comment">//初始任务(当前线程首先需要执行的任务)</span></span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="comment">//线程任务计数器(当前worker执行成功的任务数)</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="comment">//将主运行循环委托给外部 runWorker</span></span><br><span class="line">            runWorker(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">		<span class="comment">//通过AQS的同步状态来实现锁机制。state为0时代表锁未被获取（解锁状态），</span></span><br><span class="line">     	state为<span class="number">1</span>时代表锁已经被获取（加锁状态）。</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//尝试获取锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//尝试释放锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>        &#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>  &#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>      &#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line">		<span class="comment">//确保线程已经运行并且中断标志为还是false时，就执行中断操作。</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">interruptIfStarted</span><span class="params">()</span> &#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="线程池核心方法execute方法"><a href="#线程池核心方法execute方法" class="headerlink" title="线程池核心方法execute方法"></a>线程池核心方法execute方法</h2><ul>
<li>execute()方法执行流程</li>
</ul>
<ol>
<li>如果当前运行的线程少于核心线程数corePoolSize，则创建新线程来执行任务</li>
<li>当前运行的线程大于等于核心线程池数，那么就放入阻塞队列中去</li>
<li>阻塞队列已满那么就创建一个线程去执行</li>
<li>如果创建新线程使当前总线程数超过最大线程数maximumPoolSize，任务将被拒绝，线程池拒绝策略handler执行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">      <span class="comment">//获取当前线程池的ctl值</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"><span class="comment">//当前线程池有效线程数少于核心线程数</span></span><br><span class="line">      <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">	<span class="comment">//addWorker()方法可以分为增加线程数、添加任务，并执行</span></span><br><span class="line">          <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          c = ctl.get();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//isRunning()获取当前线程池是否处于运行状态,并且将其加入到阻塞队列中</span></span><br><span class="line">      <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">	<span class="comment">//双重检查机制</span></span><br><span class="line">	<span class="comment">//目的:检查是否真的需要添加一个线程，防止因为并发情况，导致线程池已经关闭，那么就不需要再创建线程</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">	<span class="comment">//如果当前线程池不处于运行状态，并且将任务从阻塞队列中删除成功，则任务由RejectedExecutionHandler处理</span></span><br><span class="line">          <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">              reject(command);</span><br><span class="line">	<span class="comment">//如果当前线程池中有效线程数为空，那么就创建一个新的线程去执行</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">              addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//执行到这步，那么只有有效线程数小于核心线程数，并且阻塞队列已满，那么就创建一个线程去执行</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">	<span class="comment">//执行拒绝策略</span></span><br><span class="line">          reject(command);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="addWorker-方法添加线程数，添加任务，执行任务"><a href="#addWorker-方法添加线程数，添加任务，执行任务" class="headerlink" title="addWorker()方法添加线程数，添加任务，执行任务"></a>addWorker()方法添加线程数，添加任务，执行任务</h2><ul>
<li>addworker的两大参数firstTask,core的含义</li>
</ul>
<ol>
<li>firstTask 新线程应该首先运行的任务（如果没有，则为 null）。</li>
<li>core为true 使用 corePoolSize 作为边界，否则 使用maximumPoolSize 作为边界</li>
</ol>
<p>&#96;&#96;Java</p>
<pre><code>private boolean addWorker(Runnable firstTask, boolean core) &#123;
    retry:
    for (;;) &#123;
        int c = ctl.get();
        //获取线程池运行状态 
        int rs = runStateOf(c);
        /*有哪些情况会返回false呢？
        1. 当线程池运行状态为Running状态时(rs&gt;=SHUTDOWN条件不满足)    
        2. 线程池子为STOP或TIDYING或TERMINATED，返回false(rs == SHUTDOWN条件不满足)
        3. 线程池的状态为SHUTDOWN，但是提交的任务不为空，返回false
        4. 线程池的状态为SHUTDOWN，提交的任务为空，但是队列为空，返回false( workQueue.isEmpty()不满足)
        */
        /*
        什么时候返回true
        线程池的状态为SHUTDOWN，提交的任务为空，队列也不为空，说明需要执行阻塞队列中的任务(SHUTDOWN刚好1. 表示不处理新任务，处理排队任务)
        */
        if (rs &gt;= SHUTDOWN &amp;&amp;
            ! (rs == SHUTDOWN &amp;&amp;
               firstTask == null &amp;&amp;
               ! workQueue.isEmpty()))
            return false;

        for (;;) &#123;
            //获取线程池中运行的线程数
            int wc = workerCountOf(c);
            //边界条件判断，是否大于线程个数限制
            if (wc &gt;= CAPACITY ||
                wc &gt;= (core ? corePoolSize : maximumPoolSize))
                return false;
            //CAS的方式增加线程数(ctl.compareAndSet(expect, expect + 1);)
            if (compareAndIncrementWorkerCount(c))
                //修改成功跳出死循环
                break retry;
            //进行到这步说明CAS修改线程数失败，那么再次获取ctl值判断是否线程池运行状态是否被修改
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                //线程池运行状态被修改，那么跳出重新进入循环，获取线程池状态
                continue retry;
            //CAS修改线程数失败,线程池运行状态没有被修改。继续进行循环
        &#125;
    &#125;
    //说明线程池中线程数已经修改成功
    boolean workerStarted = false;//工作线程是否启动
    boolean workerAdded = false;//工作线程是否增加
    Worker w = null;
    try &#123;
        //创建一个worker
        /*贴上Woker构造函数
         Worker(Runnable firstTask) &#123;
         setState(-1); // inhibit interrupts until runWorker(禁止中断直到runWorker)
         this.firstTask = firstTask;//线程需要运行的任务
         this.thread = getThreadFactory().newThread(this);//通过线程工厂创建一个线程
    &#125;
        */
        w = new Worker(firstTask);
        //获取当前线程
        final Thread t = w.thread;
        if (t != null) &#123;
            //加锁
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try &#123;
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                //重新检查线程池状态，以避免在获取锁前调用了shutdown方法
                int rs = runStateOf(ctl.get());
                //通过检查条件
                //1：线程池处于运行状态
                //2：线程池为关闭状态并且需要执行的任务为null
                if (rs &lt; SHUTDOWN ||
                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;
                    //测试是否存在此线程。如果它已启动并尚未死亡，则一个线程就活着。
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    //将线程加入到工作线程集合中去
                    workers.add(w);
                    int s = workers.size();
                    //大于线程池最大容量更新
                    if (s &gt; largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                &#125;
            &#125; finally &#123;
                //释放锁
                mainLock.unlock();
            &#125;
            if (workerAdded) &#123;
                //运行线程
                t.start();
                workerStarted = true;
            &#125;
        &#125;
    &#125; finally &#123;
        //线程运行失败，则进行回滚, 移除之前添加的Worker(workers.remove(w);)
        if (! workerStarted)
            addWorkerFailed(w);
    &#125;
    //返回是否线程是否运行成功
    return workerStarted;
&#125;
</code></pre>
<p>&#96;&#96;</p>
<h2 id="runWorker-方法执行任务-使该线程开始执行；-Java-虚拟机调用该线程的-run-方法-public-void-run-runWorker-this-最终会调用runworker方法"><a href="#runWorker-方法执行任务-使该线程开始执行；-Java-虚拟机调用该线程的-run-方法-public-void-run-runWorker-this-最终会调用runworker方法" class="headerlink" title="runWorker()方法执行任务(使该线程开始执行； Java 虚拟机调用该线程的 run 方法,public void run() {runWorker(this);}最终会调用runworker方法)"></a>runWorker()方法执行任务(使该线程开始执行； Java 虚拟机调用该线程的 run 方法,public void run() {runWorker(this);}最终会调用runworker方法)</h2><pre><code>``Java
final void runWorker(Worker w) &#123;
    //获取执行任务的线程
    Thread wt = Thread.currentThread();
    //获取执行任务
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;//根据下面没有抛异常才会更改completedAbruptly的值说明该值表示Worker执行任务是否因为异常而死亡
    try &#123;
        while (task != null || (task = getTask()) != null) &#123;//获取阻塞队列中的任务，直到当前线程池的状态大于STOP状态或者当前线程达到了超时时间就跳出循环将当前worker从线程集合中删除
            w.lock();
            
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;&amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                !wt.isInterrupted())
                wt.interrupt();
            try &#123;
                //在给定线程中执行给定 Runnable 之前调用的方法
                //这个实现什么都不做，但可以在子类中定制
                beforeExecute(wt, task);
                Throwable thrown = null;
                try &#123;
                    //执行任务
                    task.run();
                &#125; catch (RuntimeException x) &#123;
                    thrown = x; throw x;
                &#125; catch (Error x) &#123;
                    thrown = x; throw x;
                &#125; catch (Throwable x) &#123;
                    thrown = x; throw new Error(x);
                &#125; finally &#123;
                    //在完成给定 Runnable 的执行时调用的方法。 此方法由执行任务的线程调用
                    //这个实现什么都不做，但可以在子类中定制
                    afterExecute(task, thrown);
                &#125;
            &#125; finally &#123;
                //任务执行完清空
                task = null;
                //当前worker执行任务数++
                w.completedTasks++;
                //释放锁
                w.unlock();
            &#125;
        &#125;
        //当线程池中任务已经执行完推出while循环
        completedAbruptly = false;
    &#125; finally &#123;
        //到达这里说明当前worker中的线程达到了超时时间需要被移除不能再去获取阻塞队列中的任务去执行
        //执行Worker退出的方法processWorkerExit
        processWorkerExit(w, completedAbruptly);
    &#125;
&#125;

``
</code></pre>
<h2 id="getTask-获取阻塞队列中的任务"><a href="#getTask-获取阻塞队列中的任务" class="headerlink" title="getTask()获取阻塞队列中的任务"></a>getTask()获取阻塞队列中的任务</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?(最后一次poll()是否超时)</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">		<span class="comment">//获取线程池运行状态</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Check if queue empty only if necessary.(在必要时检查队列是否为空)</span></span><br><span class="line">		<span class="comment">//大于SHUTDOWN的运行时状态只有Stop，TIDYING， TERMINATED</span></span><br><span class="line">           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">               decrementWorkerCount();<span class="comment">//将运行线程数量-1</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">		<span class="comment">//获取当前运行线程数</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">		<span class="comment">//判断当前的worker是否需要被移除(超时，大于核心线程数，或者allowCoreThreadTimeOut设置为ture)</span></span><br><span class="line">		<span class="comment">//allowCoreThreadTimeOut属性的含义</span></span><br><span class="line">           <span class="comment">// If false (default), core threads stay alive even when idle(如果为 false（默认），核心线程即使在空闲时也保持活动状态)</span></span><br><span class="line">		<span class="comment">//If true, core threads use keepAliveTime to time out waiting for work(如果为真，核心线程使用 keepAliveTime 超时等待工作)</span></span><br><span class="line">		<span class="comment">//当前线程大于核心线程数，那么当前线程是有超时时间的(keepAliveTime),那么就无法一直等待任务执行</span></span><br><span class="line">           <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">		<span class="comment">//当运行的线程数大于了线程池最大线程数或者，或者当前线程会超时并且已经超时</span></span><br><span class="line">           <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">               &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;<span class="comment">//阻塞队列不为空，确保能移除worker</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))<span class="comment">//将线程池运行线程数减一(具体将worker移除是在processWorkerExit方法中)</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//当前worker中的线程达到了设置的超时时间需要被移除不能再获取任务</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">		<span class="comment">//执行到这里，WorkerCount已经减去了空闲线程数</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 根据线程是否会超时调用相应的方法，poll为带超时的获取任务方法，第一个参数为超时时间，第二个参数单位</span></span><br><span class="line">               <span class="comment">// take()为不带超时的获取任务方法，会一直阻塞直到获取到任务(将阻塞队列头部元素移除)</span></span><br><span class="line">               <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                   workQueue.take();</span><br><span class="line">               <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> r;<span class="comment">//返回运行任务</span></span><br><span class="line">               timedOut = <span class="literal">true</span>;<span class="comment">//当前线程获取执行任务超时(在有效时间内没有获取到任务那么worker可能需要被移除，看是否到达了最大核心线程数或者设置了allowCoreThreadTimeOut为true)</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;<span class="comment">//被中断</span></span><br><span class="line">               timedOut = <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="processWorkerExit-从集合中移除woker的方法"><a href="#processWorkerExit-从集合中移除woker的方法" class="headerlink" title="processWorkerExit()从集合中移除woker的方法"></a>processWorkerExit()从集合中移除woker的方法</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当前线程在getTask()方法中是否是异常退出</span></span><br><span class="line">	<span class="comment">//true代表是异常推出，那么需要将线程池中有效线程数减一</span></span><br><span class="line">	<span class="comment">//false正常退出,那么就不需要将有效线程数再减一,因为正常退出在f ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))&amp;&amp; (wc &gt; 1 || workQueue.isEmpty()))判断为真时也即使当前线程达到了超时时间就已经将线程池运行线程数减一</span></span><br><span class="line">       <span class="keyword">if</span> (completedAbruptly) </span><br><span class="line">           decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取lock锁</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">       mainLock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//将总的任务完成数加上当前worker的任务完成数</span></span><br><span class="line">           completedTaskCount += w.completedTasks;</span><br><span class="line">		<span class="comment">//移除当前woker从集合中</span></span><br><span class="line">           workers.remove(w);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           mainLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       tryTerminate();<span class="comment">//有Worker线程移除，可能是最后一个线程退出，需要尝试终止线程池</span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();<span class="comment">//获取线程池中ctl值</span></span><br><span class="line">       <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;<span class="comment">//为真说明当前线程池运行状态为Running和Shutdown</span></span><br><span class="line">           <span class="keyword">if</span> (!completedAbruptly) &#123;<span class="comment">//如果Worker不是异常死亡</span></span><br><span class="line">			<span class="comment">//min为线程池的理论最小线程数:如果允许核心线程超时则min为0,否则min为核心线程数</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">			<span class="comment">//如果min为0,工作队列不为空,将min设置为1,确保至少有1个Worker来处理队列里的任务 </span></span><br><span class="line">               <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                   min = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//当前有效的线程数&gt;=min，直接返回</span></span><br><span class="line">               <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                   <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">           &#125;</span><br><span class="line">           addWorker(<span class="literal">null</span>, <span class="literal">false</span>);<span class="comment">// 添加一个Worker</span></span><br><span class="line">		<span class="comment">//两种情况会添加一个worker   1）被移除的Worker是由于异常而死亡；2）被移除的Worker是最后一个Worker，但是工作队列还有任务。</span></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="tryTerminate-尝试终止线程池"><a href="#tryTerminate-尝试终止线程池" class="headerlink" title="tryTerminate()尝试终止线程池"></a>tryTerminate()尝试终止线程池</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">		<span class="comment">// 只有当前状态为STOP 或者 SHUTDOWN并且队列为空，才会尝试整理并终止</span></span><br><span class="line">       	<span class="comment">// 1: 当前状态为RUNNING，则不尝试终止，直接返回</span></span><br><span class="line">       	<span class="comment">// 2: 当前状态为TIDYING或TERMINATED，代表有其他线程正在执行终止，直接返回</span></span><br><span class="line">      		<span class="comment">// 3: 当前状态为SHUTDOWN 并且 workQueue不为空，说明阻塞队列中还有任务，不能终止，直接返回</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">               runStateAtLeast(c, TIDYING) ||</span><br><span class="line">               (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//说明通过了前面的校验</span></span><br><span class="line">           <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate(有资格中断)</span></span><br><span class="line">               interruptIdleWorkers(ONLY_ONE);<span class="comment">//中断可能正在等待任务的线程</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">		<span class="comment">//获取lock锁</span></span><br><span class="line">           <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">           mainLock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//将线程池ctl更新为TIDYING状态，并且运行线程数为0(TIDYING说明所有任务都已终止，workerCount 为零， 转换到状态 TIDYING 的线程 将运行 terminate() 钩子方法)</span></span><br><span class="line">               <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       terminated();<span class="comment">//Executor 终止时调用的方法。默认实现什么都不做，子类通常应在此方法中调用 </span></span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					<span class="comment">//将ctl的运行状态设置为TERMINATED，有效线程数设置为0</span></span><br><span class="line">                       ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                       termination.signalAll();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               mainLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// else retry on failed CAS(否则重试失败的 CAS,存在并发竞争)</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>

    </div>

    
    
    
	
	
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>小鲸鱼
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2022/03/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3(ThreadPoolExecutor)(2)/" title="线程池源码详解(ThreadPoolExecutor)(2)">http://example.com/2022/03/22/线程池源码详解(ThreadPoolExecutor)(2)/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag"># 线程池</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2022/03/22/leetcode-2022-3-23/" rel="next" title="leetcode_2022/3/23">
      leetcode_2022/3/23 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81NTgyMi8zMjI4Nw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#THREADPOOLEXECUTOR%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%8F%8A%E5%86%85%E9%83%A8%E7%B1%BBWORKER%E7%9A%84%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.</span> <span class="nav-text">THREADPOOLEXECUTOR成员变量及内部类WORKER的属性详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95execute%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">线程池核心方法execute方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#addWorker-%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%8C%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="nav-number">3.</span> <span class="nav-text">addWorker()方法添加线程数，添加任务，执行任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runWorker-%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1-%E4%BD%BF%E8%AF%A5%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%EF%BC%9B-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%B0%83%E7%94%A8%E8%AF%A5%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E6%96%B9%E6%B3%95-public-void-run-runWorker-this-%E6%9C%80%E7%BB%88%E4%BC%9A%E8%B0%83%E7%94%A8runworker%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">runWorker()方法执行任务(使该线程开始执行； Java 虚拟机调用该线程的 run 方法,public void run() {runWorker(this);}最终会调用runworker方法)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getTask-%E8%8E%B7%E5%8F%96%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="nav-number">5.</span> <span class="nav-text">getTask()获取阻塞队列中的任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#processWorkerExit-%E4%BB%8E%E9%9B%86%E5%90%88%E4%B8%AD%E7%A7%BB%E9%99%A4woker%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">processWorkerExit()从集合中移除woker的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tryTerminate-%E5%B0%9D%E8%AF%95%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">7.</span> <span class="nav-text">tryTerminate()尝试终止线程池</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小鲸鱼"
      src="/images/whole.png">
  <p class="site-author-name" itemprop="name">小鲸鱼</p>
  <div class="site-description" itemprop="description">凡事以理想为因,实行为过</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-02 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小鲸鱼</span>
</div>
  <div class="powered-by">تطبيق الموقع <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
